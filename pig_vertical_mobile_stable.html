<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>pig</title>
<style>
html,body{margin:0;padding:0;background:#ffffff;height:100%;overflow:hidden;}
canvas{display:block;width:100vw;height:100vh;}
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  const INK = "#111";
  const RED = "#ff0000";

  let W=0,H=0;
  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // 控制上限，避免高DPR爆内存
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = "100vw";
    canvas.style.height = "100vh";
    ctx.setTransform(dpr,0,0,dpr,0,0); // 之后用CSS像素绘制
    W = window.innerWidth;
    H = window.innerHeight;
    rebuildShapes(); // 只在尺寸变化时重建点集，避免每帧分配大量数组导致闪退
  }
  window.addEventListener("resize", resize);

  function clear(){
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,W,H);
  }

  // ---------- 稳定随机 ----------
  function mulberry32(seed){
    return function(){
      let t = seed += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  function jitter(x,y,rand,a){
    return [x+(rand()*2-1)*a,y+(rand()*2-1)*a];
  }

  // ---------- 点集生成（重建时用，不要每帧生成） ----------
  function ellipsePoints(cx,cy,rx,ry,steps=160){
    const pts=[];
    for(let i=0;i<=steps;i++){
      const t=i/steps*Math.PI*2;
      pts.push([cx+Math.cos(t)*rx,cy+Math.sin(t)*ry]);
    }
    return pts;
  }
  function quad(p0,p1,p2,steps=70){
    const pts=[];
    for(let i=0;i<=steps;i++){
      const t=i/steps;
      const x=(1-t)*(1-t)*p0[0]+2*(1-t)*t*p1[0]+t*t*p2[0];
      const y=(1-t)*(1-t)*p0[1]+2*(1-t)*t*p1[1]+t*t*p2[1];
      pts.push([x,y]);
    }
    return pts;
  }
  function line(x1,y1,x2,y2,steps=45){
    const pts=[];
    for(let i=0;i<=steps;i++){
      const t=i/steps;
      pts.push([x1+(x2-x1)*t,y1+(y2-y1)*t]);
    }
    return pts;
  }

  // ---------- 手绘描边（轻量版） ----------
  function drawStroke(points,progress,opt){
    const {seed=1,width=6,amp=1.4,color=INK,passes=2} = opt||{};
    const n=points.length;
    const k=Math.max(2, Math.floor(n*Math.max(0,Math.min(1,progress))));

    for(let pass=0; pass<passes; pass++){
      const rand=mulberry32(seed + pass*997);
      ctx.save();
      ctx.globalAlpha = pass===0 ? 1 : 0.65;
      ctx.strokeStyle=color;
      ctx.lineWidth=width*(pass===0?1:0.92);
      ctx.lineCap="round";
      ctx.lineJoin="round";
      ctx.beginPath();
      let [x,y]=jitter(points[0][0],points[0][1],rand,amp*0.7);
      ctx.moveTo(x,y);
      for(let i=1;i<k;i++){
        const localAmp = amp*(0.7 + 0.3*Math.sin(i*0.12));
        [x,y]=jitter(points[i][0],points[i][1],rand,localAmp);
        ctx.lineTo(x,y);
        if(i%30===0){ ctx.stroke(); ctx.beginPath(); ctx.moveTo(x,y); }
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  // ---------- 缓存形状点集（关键：避免闪退） ----------
  let shapes = null;

  function rebuildShapes(){
    const cx = W/2;
    const cy = H*0.42;              // 竖屏上方一点，下面留空间给彩带
    const scale = Math.min(W,H)/520;

    shapes = {
      cx, cy, scale,
      face: ellipsePoints(cx, cy, 150*scale, 145*scale, 200),
      leftEar: [
        ...quad([cx-95*scale,cy-105*scale],[cx-190*scale,cy-175*scale],[cx-175*scale,cy-35*scale],70),
        ...quad([cx-175*scale,cy-35*scale],[cx-125*scale,cy],[cx-95*scale,cy-62*scale],55),
      ],
      rightEar: [
        ...quad([cx+95*scale,cy-105*scale],[cx+190*scale,cy-175*scale],[cx+175*scale,cy-35*scale],70),
        ...quad([cx+175*scale,cy-35*scale],[cx+125*scale,cy],[cx+95*scale,cy-62*scale],55),
      ],
      eyeL: ellipsePoints(cx-50*scale, cy-48*scale, 16*scale, 12*scale, 110),
      eyeR: ellipsePoints(cx+50*scale, cy-48*scale, 16*scale, 12*scale, 110),
      snout: ellipsePoints(cx, cy+45*scale, 78*scale, 56*scale, 150),
      nostrilL: ellipsePoints(cx-28*scale, cy+45*scale, 10*scale, 16*scale, 90),
      nostrilR: ellipsePoints(cx+28*scale, cy+45*scale, 10*scale, 16*scale, 90),
      mouth: quad([cx-45*scale,cy+95*scale],[cx,cy+125*scale],[cx+45*scale,cy+95*scale],95),

      // 红字 Yeah~ 也用笔画（简单线稿，稳定不耗内存）
      yeahStrokes: (() => {
        const baseY = cy - 10;
        const startX = cx - 120*scale;
        const h = 90*scale;
        const w = 60*scale;
        const gap = 16*scale;
        const top = baseY - h/2;
        const bottom = baseY + h/2;
        const mid = baseY;

        const xY = startX;
        const xe = xY + w + gap;
        const xa = xe + w + gap;
        const xh = xa + w + gap;
        const xT = xh + w + gap;

        const strokes = [];
        // Y
        strokes.push(line(xY, top, xY + w*0.5, mid - 6*scale, 40));
        strokes.push(line(xY + w, top, xY + w*0.5, mid - 6*scale, 40));
        strokes.push(line(xY + w*0.5, mid - 6*scale, xY + w*0.5, bottom, 55));
        // e: 小圈 + 横
        strokes.push(ellipsePoints(xe + w*0.48, mid + 8*scale, 18*scale, 18*scale, 90));
        strokes.push(line(xe + w*0.18, mid + 8*scale, xe + w*0.82, mid + 8*scale, 28));
        // a: 圈 + 尾巴
        strokes.push(ellipsePoints(xa + w*0.45, mid + 10*scale, 18*scale, 18*scale, 90));
        strokes.push(quad([xa + w*0.62, mid - 5*scale],[xa + w*0.95, mid + 5*scale],[xa + w*0.70, mid + 30*scale],70));
        // h: 竖 + 拱
        strokes.push(line(xh + w*0.2, top, xh + w*0.2, bottom, 70));
        strokes.push(quad([xh + w*0.2, mid - 8*scale],[xh + w*0.78, mid - 35*scale],[xh + w*0.75, mid + 25*scale],90));
        // ~
        const tY = baseY + 52*scale;
        strokes.push(quad([xT, tY],[xT + 30*scale, tY - 18*scale],[xT + 60*scale, tY],70));
        strokes.push(quad([xT + 60*scale, tY],[xT + 90*scale, tY + 18*scale],[xT + 120*scale, tY],70));
        return strokes;
      })()
    };

    // 彩带也重置一下，让效果更一致
    ribbons = [];
  }

  // ---------- 彩带 ----------
  let ribbons=[];
  function initRibbons(){
    const rand = mulberry32(2026);
    const count = 140;
    ribbons = Array.from({length:count}, () => ({
      x: rand()*W,
      y: -rand()*H,
      vy: 1.8 + rand()*3.0,
      vx: (rand()*2-1)*0.6,
      w: 6 + rand()*10,
      h: 14 + rand()*28,
      rot: rand()*Math.PI*2,
      vr: (rand()*2-1)*0.12,
      hue: rand()*360,
      sway: rand()*Math.PI*2,
      swaySpeed: 0.02 + rand()*0.04
    }));
  }

  function drawRibbons(dt){
    const t = dt/16.67;
    for(const r of ribbons){
      r.sway += r.swaySpeed*t;
      r.x += (r.vx + Math.sin(r.sway)*0.8)*t;
      r.y += r.vy*t;
      r.rot += r.vr*t;

      if(r.y > H+60){ r.y = -60; r.x = Math.random()*W; }
      if(r.x < -60) r.x = W+60;
      if(r.x > W+60) r.x = -60;

      ctx.save();
      ctx.translate(r.x, r.y);
      ctx.rotate(r.rot);
      ctx.fillStyle = `hsl(${r.hue},90%,60%)`;
      ctx.globalAlpha = 0.95;
      ctx.fillRect(-r.w/2, -r.h/2, r.w, r.h);
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#000";
      ctx.fillRect(-r.w/2, -r.h/2 + r.h*0.55, r.w, r.h*0.18);
      ctx.restore();
    }
  }

  // ---------- 画完整猪头 ----------
  function drawPigComplete(){
    const s = shapes;
    const sc = s.scale;
    drawStroke(s.face, 1, {seed:10, width:7*sc, amp:2.0*sc});
    drawStroke(s.leftEar, 1, {seed:21, width:6*sc, amp:2.2*sc});
    drawStroke(s.rightEar, 1,{seed:22, width:6*sc, amp:2.2*sc});
    drawStroke(s.eyeL, 1, {seed:31, width:4.2*sc, amp:1.3*sc, passes:2});
    drawStroke(s.eyeR, 1, {seed:32, width:4.2*sc, amp:1.3*sc, passes:2});
    drawStroke(s.snout, 1,{seed:41, width:5.2*sc, amp:1.8*sc});
    drawStroke(s.nostrilL, 1,{seed:51, width:4.2*sc, amp:1.1*sc, passes:2});
    drawStroke(s.nostrilR, 1,{seed:52, width:4.2*sc, amp:1.1*sc, passes:2});
    drawStroke(s.mouth, 1,{seed:61, width:5.0*sc, amp:1.6*sc});
  }

  // ---------- 手写 Yeah~ ----------
  function drawYeah(p){
    const s = shapes;
    const strokes = s.yeahStrokes;
    const n = strokes.length;
    const scaled = Math.max(0,Math.min(1,p))*n;
    const full = Math.floor(scaled);
    const rest = scaled-full;

    const sc = s.scale;
    for(let i=0;i<full;i++){
      drawStroke(strokes[i], 1, {seed:900+i*17, width:6.2*sc, amp:1.2*sc, color:RED, passes:3});
    }
    if(full < n){
      drawStroke(strokes[full], rest, {seed:900+full*17, width:6.2*sc, amp:1.2*sc, color:RED, passes:3});
    }
  }

  // ---------- 流程 ----------
  const steps = [
    {name:"face", dur:1200, render:(p)=>{
      clear();
      const s = shapes, sc=s.scale;
      drawStroke(s.face, p, {seed:10, width:7*sc, amp:2.0*sc});
    }},
    {name:"ears", dur:900, render:(p)=>{
      clear();
      const s = shapes, sc=s.scale;
      drawStroke(s.face, 1, {seed:10, width:7*sc, amp:2.0*sc});
      drawStroke(s.leftEar, p, {seed:21, width:6*sc, amp:2.2*sc});
      drawStroke(s.rightEar, p,{seed:22, width:6*sc, amp:2.2*sc});
    }},
    {name:"eyes", dur:700, render:(p)=>{
      clear();
      const s = shapes, sc=s.scale;
      drawStroke(s.face, 1, {seed:10, width:7*sc, amp:2.0*sc});
      drawStroke(s.leftEar, 1, {seed:21, width:6*sc, amp:2.2*sc});
      drawStroke(s.rightEar, 1,{seed:22, width:6*sc, amp:2.2*sc});
      drawStroke(s.eyeL, p, {seed:31, width:4.2*sc, amp:1.3*sc, passes:2});
      drawStroke(s.eyeR, p, {seed:32, width:4.2*sc, amp:1.3*sc, passes:2});
    }},
    {name:"snout", dur:800, render:(p)=>{
      clear();
      const s = shapes, sc=s.scale;
      drawStroke(s.face, 1, {seed:10, width:7*sc, amp:2.0*sc});
      drawStroke(s.leftEar, 1, {seed:21, width:6*sc, amp:2.2*sc});
      drawStroke(s.rightEar, 1,{seed:22, width:6*sc, amp:2.2*sc});
      drawStroke(s.eyeL, 1, {seed:31, width:4.2*sc, amp:1.3*sc, passes:2});
      drawStroke(s.eyeR, 1, {seed:32, width:4.2*sc, amp:1.3*sc, passes:2});
      drawStroke(s.snout, p,{seed:41, width:5.2*sc, amp:1.8*sc});
    }},
    {name:"details", dur:900, render:(p)=>{
      clear();
      drawPigComplete();
      const s = shapes, sc=s.scale;
      const p1 = Math.min(1, p*1.2);
      const p2 = Math.max(0, Math.min(1, (p-0.25)*1.6));
      drawStroke(s.nostrilL, p1,{seed:51, width:4.2*sc, amp:1.1*sc, passes:2});
      drawStroke(s.nostrilR, p1,{seed:52, width:4.2*sc, amp:1.1*sc, passes:2});
      drawStroke(s.mouth, p2,{seed:61, width:5.0*sc, amp:1.6*sc});
    }},
    {name:"yeah", dur:1400, render:(p)=>{
      clear();
      drawPigComplete();
      drawYeah(p);
    }},
    {name:"confetti", dur:2600, onEnter:()=>{ initRibbons(); }, render:(p,dt)=>{
      clear();
      drawPigComplete();
      drawYeah(1);
      drawRibbons(dt);
    }},
  ];

  let idx=0;
  let start=0;
  let last=0;
  let entered=false;

  function tick(t){
    if(!shapes){ requestAnimationFrame(tick); return; }
    if(!start){ start=t; last=t; }
    const step = steps[idx];
    if(step.onEnter && !entered){ entered=true; step.onEnter(); }

    const elapsed = t-start;
    const p = Math.min(1, elapsed/step.dur);
    const dt = t-last; last=t;

    if(step.name==="confetti") step.render(p, dt);
    else step.render(p);

    if(p>=1){
      idx++;
      start=t;
      last=t;
      entered=false;
      if(idx>=steps.length) idx=steps.length-1; // 停在最后彩带阶段
    }
    requestAnimationFrame(tick);
  }

  // 启动
  resize();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
